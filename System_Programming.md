# 시스템 프로그래밍(200227)

## 리눅스

* 클라우드 컴퓨팅(AWS)
* 운영체제, 소프트웨어의 대부 UNIX 계열 운영체제
  * 완전 프로그래머 스타일
* Plain 하게 프로그래밍이 가능 + ANSI C - C 언의 표준

* GPL 라이선스
  * GPL 프로그램은 어떤 목적으로, 어떤 형태로든 사용할 수 있지만, 사용하거나 변경된 프로그램을 다시 배포하는 경우, 동일한 GPL 라이선스로 공개를 해야함
  * 소스 오픈을 장려하기 위함
  * 오픈 소스 운동
  * 운영체제 개발 - OS kernel, System call, Compiler, API, Shell, Editor
  * 소스 라이선스 - GPL
  * GNU/Linux





### 클라우드 컴퓨팅 설정

1. EC2 또는 인스턴스(서버) 생성
2. Elastic IP(탄력적 IP) 생성 
3. 자기 PC(클라이언트)에서 EC2(서버) 접속



### 리눅스와 파일

* 모든 것은 파일이라는 철학을 따름
  * 모든 인터렉션은 파일을 읽고, 쓰는 것처럼 이루어져있음
  * 마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다루어짐
* 파일 네임스페이스
  * 전역 네임스페이스를 제공 /media/floofy/dave.jpg
  * C드라이브 (C:/)
* 파일은 inode 고유값과 자료구조에 의해 주요 정보 관리



### 리눅스와 프로세스

* 리눅스 실행 파일 포멧 - ELF(Executable and Linkable Format)
  * 콜스택, 코드(텍스트), 데이터 및 BSS 섹션 등
* 다양한 시스템 리소스와 관련
  * 시스템콜 호출을 통해 리소스 처리 가능토록 구성
    * 타이머, 시그널, 파일, 네트워크, 디바이스, IPC기법
* 가상 메모리 지원
* 각 프로세스는 pid(프로세스 ID) 고유값으로 구분
* init 프로세스(첫 번째 프로세스)를 기반으로 fork() 시스템콜을 사용해서, 신규프로세스가 생성



### 리눅스와 권한

* 운영체제는 사용자/리소스 권한을 관리
* 리눅스는 사용자/그룹으로 권한을 관리
* root는 슈퍼관리자
* 파일마다 소유자, 소유자 그룹, 모든 사용자에 대해 
  * 읽고, 쓰고, 실행하는 권한을 관리
  * 접근 권한 정보는 inode의 자료구조에 저장



### 쉘

: 사용자와 운영체제간 인터페이스

* 사용자의 명령을 해석해서, 커널에 명령을 요청해주는 역할
* 관련된 시스템콜을 사용해서 프로그래밍이 작성되어 있다.

* 쉘 종류

  * Bourne-Again Shell(bash): GNU 프로젝트의 일환으로 개발됨, 리눅스
  * Bourne Shell(sh)
  * C Shell(csh)
  * Korn Shell(ksh): 유닉스에서 가장 많이 사용됨

* 리눅스 기본 명령어 정리

  * 리눅스 명령어는 결국 쉘이 제공하는 명령어
  * 리눅스 기본 쉘이 bash이므로, bash에서 제공하는 기본 명령어를 배우는 것

* UNIX는 다중 사용자를 지원하는 시스템

  * 다중 사용자 관련 명령어 알아보기

  ```
  ## passwd : 로그인한 사용자 ID의 암호 변경
  ## useradd: 사용자 기본 설정 자동으로 하지 않음
  ## adduser: 사용자 기본 설정을 자동으로 수행함
  ## su : 사용자 변경
  	* su root : 현재 사용자의 환경설정 기반, root로 변경
  	* su -root : 변경되는 사용자의 환경설정을 기반으로, root로 전환
  ## pwd : 현재 디렉토리 위치
  
  ```

  ### Standard Stream (표준 입출력)

* command 로 실행되는 프로세스는 세 가시 스트림을 가지고 있음
  * 표준 입력 스트림(Standard Input Strea) - stdin
  * 표준 출력 스트림(Standard Output Stream) -stdout
  * 오류 출력 스트림(Standard Error Stream) - stderr
* 모든 스트림은 일반적인 plain text로 console에 출력하도록 되어 있음



### 리다이렉션(redirection)

* 표준 스트림 흐름을 바꿔줄 수 있다.
  * ,< 을 사용함
  * 주로 명령어 표준 출력을 화면이 아닌 파일에 쓸 때 사용함

```
1. ls> files.txt
	- ls 로 출력되는 표준 출력 스트림의 방향을 files.txt로 바꿔줌
	(files.txt 에 ls 로 출력되는 결과가 저장됨)
2. head < files.txt
	- files.txt의 파일 내용이 head라는 파일의 처음부터 10라인까지 출력해주는 명령으로 넣어짐
3. head <files.txt>files2.txt
	- files.txt의 파일 내용이 head로 들어가서, files.txt의 앞 10라인을 출력
	- head의 출력 스트림은 다시 files2.txt로 들어감
	- head 는 files.txt내용을 출력하지 않고, 해당 출력 내용이 다시 files2.txt에 저장됨
		-> 결과적으로 files.txt 의 앞 10 라인이 files2.txt에 저장됨.
4. 기존 파일에 추가는 >> 또는 << 사용
	- ls >> files.txt
	- 기존에 있는 files.txt 파일 끝에, ls 출력 결과를 추가해줌

```



### 파이프(pipe)

* 두 프로세스 사이에서 한 프로세스의 출력 스트림을 또다른 프로세스의 입력스트림으로 사용할 때 사용됨

```
EX) ls | grep files.txt
	- ls 명령을 통한 출력 내용이 grep 명령의 입력 스트림으로 들어감
	- grep files.tdxt는 grep 명령의 입력 스트림을 검색해서 files.txt가 들어 있는 입력 내용만 출력
	- 따라서 ls 명령으로 해당 디렉토리/파일 중에 files.txt파일이 있는지를 출력해줌

```



### 프로세스 vs 바이너리

* 코드 이미지 또는 바이너리 : 실행파일
* 실행 중인 프로그램: 프로세스
  * 가상 메모리 및 물리 메모리 정보
  * 시스템 리소스 관련 정보
  * 스케쥴링 단위



### 리눅스는 다양한 프로세스 실행 환경

* 리눅스는 기본적으로 다양한 프로세스가 실행됨
  * 유닉스 철학: 여러 프로그램이 서로 유기적으로 각자의 일을 수행하면서 전체 시스템이 동작하도록 하는 모델

### foreground process/ background process

* foreground process: 쉘(shell)에서 해당 프로세스 실행을 명령한 수, 해당 프로세스 수행 종료까지 사용자가 다른 입력을 하지 못하는 프로세스
* background process: 사용자 입력과 상관없이 실행되는 프로세스
  * 쉘(shell)에서 해당 프로세스 실행시, 맨 뒤에&를 붙여줌



### 프로세스 상태 확인 - ps 명령어

* 사용법: ps
* 데몬 프로세스(daemon process): 사용자 모르게 시스템 관리를 위해 실행되는 프로세스로 보통 시스템이 부팅될 때 자동 실행(예: ftpd, inetd)



### 슈퍼블록, inode와 파일

* 슈퍼블록: 파일 시스템의 정보
* 파일 : inode 고유값과 자료구조에 의해 주요 정보 관리
  * ''파일이름:inode' 로 파일이름은 inode 번호와 매칭
  * 파일 시스템에서는 inode를 기반으로 파일 엑세스
  * inode기반 메타 데이터 저장

### 리눅스 파일 시스템(ext file system) 과 inode

* inode 기반 메타 데이터(파일 권한, 소유자 정보, 파일 사이즈, 생성기간 등 시간관련 정보, 데이터 저장 위치 등)



### 파일과 inode

* 리눅스 파일 탐색: 예 -/home/ubuntu/link.txt
  * 각 디렉토리 엔트리(dentry) 를 탐색
    * 각 엔트리는 해당 디렉토리 파일/디렉토리 정보를 가지고 있음
  * '/' dentry에서 'home' 을 찾고, 'home' 에서 'ubuntu' 를 찾고, 'ubuntu'에서 link.txt파일이름에 해당하는 inode를 얻음



### 하드 링크와 소프트 링크

* cp 명령:  파일 복사
  * 1MB 사이즈를 가지고 있는 A 파일을 B 파일로 복사
    * cp A B -> A와 B는 각각 물리적으로 10MB 파일로 저장
* 하드 링크: ln A B
  * A 와 B는 동일한 10MB 파일을 가리킴
  * 즉, 동일한 파일을 가진 이름을 하나 더 만든 것일 뿐
    * 그래서, inode는 동일!
    * 전체 파일 용량은 달라지지 않음
  * ls - i (파일 inode 확인하기)
  * ls -al (완전 동일한 파일)
  * rm A로 A를 삭제하면? B는 그래도 해당 파일 접근 가능
    * 'A:해당 inode' 이 정보만 삭제되고, inode를 가진 실제 파일은 그대로 남음
* 소프트(심볼릭) 링크: ln -s A B
  * Windows OS의 바로가기와 동일
  * ls -al 하면, 소프트 링크 확인 가능
  * rm A 로 A를 삭제하면? B는 해당 파일 접근 불가



### 특수파일

* 디바이스

  * 블록 디바이스(Block Device)

    : HDD, CD/DVD와 같이 블록 또는 섹터 등 정해진 단위로 데이터 전송, IO 송수신 속도가 높음

  * 캐릭터 디바이스(Character Device)

    : 키모드, 마우스 등 byte 단위 데이터 전송, IO 송수신 속도가 낮음

  * cd /dev, cat tty



### 시스템 프로그래밍의 기반 요소

* 시스템 콜(system call)
* C 라이브러리
* C 컴파일러



### 시스템 콜

* 시스템 콜: 운연체제 리소스나 서비스 요청을 위해, 사용자 영역에서 커널 영역으로 들어가는 함수
* 주요 시스템콜: read(), write(), open() 등
* 시스템 콜은 어떻게 구현??
  * 소프트웨어 인터럽트 명령을 호출하면서 0x80 값을 넘겨줌
    * CPI는 사용자 모드를 커널 모드로 바꿔줌
    * IDT(Interript Descriptor Table) 에서 0x80에 해당하는 주소(함수) 를 찾아서 실행함
    * system_call() 함수에서 eax 로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
    * 해당 시스템콜 함수 실행 후, 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음코드 진행

### C 라이브러리

* 유닉스 C 라이브러리 - libc
* 리눅스 C 라이브러리 - GNU libc- glibc(지립씨, 글립씨)
  * 시스템콜, 시스템콜 래퍼, 기본 응용 프로그램 기능 포함

### C 컴파일러

* 유닉스 C 컴파일러 -cc

* 리눅스 C 컴파일러 - GNU cc-gcc

* 우분투 리눅스에 gcc 설치

  ```
  sudo apt-get install gcc
  gcc --version
  gcc -o test.c test
  ```

  

### API

* 응용 프로그램과 분리된 하위 호환 인터페이스
  * 예: 시스템 콜 래퍼, 입출력 라이브러리 등



### ABI

* 응용 프로그램 바이너리 인터페이스
* 함수 실행 방식, 레지스터 활용, 시스템 콜 실행, 라이브러리 링크 방식 등
* ABI가 호환되면 재컴파일없이 동작
* 컴파일러, 링커(라이브러리 링크), 툴체인(컴파일러를 만드는 프로그램) 에서 제공



### POSIX

* 유닉스 시스템 프로그래밍 인터페이스 표준
* IEEE(Institute of Eletronic and Elctronics Engineers)에서 표준화 시도
* 리차드 스톨만(자유 소프트웨어 재단) 이 POSIX를 표준안 이름으로 제안



### 시스템 프로그래밍과 버전

* 끊임없는 POSIX, C, C++ 표준 업데이트
* 끊임없는 소프트웨어 업데이트
* 프로그래밍 트렌드와 상관없이 시스템 레벨단 기술은 유지되고, 필요함

### 프로세스 관리 - 프로세스 ID

* 프로그램: 바이너리, 코드 이미지, 응용 프로그램, Application 또는 실행 파일
* 프로세스: 실행 중인 프로그램(메모리 적재+ 프로세스 상태 정보 포함)
* 스레드(Thread)
  * 리눅스 프로세스는 기본 스레드 포함
  * 싱글스레드 프로세스: 기본 프로세스
  * 멀티스레드 프로세스: 여러 스레드 존재



### 프로세스 ID

* pid, 각 프로세스는 해당 시점에 unique 한 pid를 가짐
* pid 최대 값은 329768
* 부호형(signed) 16비트 정수 값 사용

```
sudo vi /proc/sys/kernel/pid_max
```

* 최근 할당된 pid가 200이라면, 그 이후에 201, 202 가 할당됨.

### 프로세스 계층

* 최초 프로세스 : init 프로세스, pid 1
* init 프로세스는 운영체제가 생성
* 다른 프로세스는 또다른 프로세스로부터 생성
  * 부모, 자식
* ppid 값이 부모 프로세스의 pi를 뜻함
* ppid 값 확인해보기

```
ps -ef
```

### 프로세스와 소유자(owner) 관리

* 리눅스 내부에서는 프로세스의 소유자(사용자)와 그룹을 UID/GID(정수)로 관리
* 사용자에 보여줄때에만 UID와 사용자이름 매핑 정보를 기반으로 사용자 이름으로 제공

 ### 프로세스 관리 관련 시스템 콜

* 사전작업: 우분투 리눅스에 gcc 설치

### 프로세스 생성

* 기본 프로세스 생성 과정
  * TEXT, DATA, BSS, HEAP, STACK 의 공간을 생성
  * 프로세스 이미지를 해당 공간에 업로드하고 실행 시작
* 프로세스 계층: 다른 프로세스는 또다른 프로세스로부터 생성
  * 부모, 자식



### fork(), exec() 시스템 콜

* fork() 시스템콜
  * 새로운 프로세스 공간을 별도로 만들고, fork() 시스템콜을 호출한 프로세스(부모) 공간을 모두 복사
    * 별도의 프로세스 공간을 마들고, 부모프로세스 공간의 데이터를 그대로 복사
  * 자식 프로세스는 pid 가 0 으로 리턴, 부모프로세스는 실제 pid 리턴
  * 두 프로세스의 변수 및 PC(Program Count) 값은 동일
* exec() 시스템콜
  * exec() 시스템콜을 호출한 현재 프로세스 공간의 TEXT, DATA, BSS 영역을 새로운 프로세스의 이미지로 덮어씌움
    * 별도의 프로세스 공간을 만들지 않음

### wait() 시스템콜

* wait() 함수를 사용하면, fork() 함수호출시, 자식 프로세스가 종료할 때까지, 부모 프로세스가 기다림
* 자식 프로세스와 부모 프로세스의 동기화, 부모 프로세스가 자식 프로세스보다 먼저 죽는 경우를 막기 위해 사용(고아 프로세스)
